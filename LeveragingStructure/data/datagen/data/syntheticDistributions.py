# AUTOGENERATED! DO NOT EDIT! File to edit: 01_F_DataGen_Synthetic_Distributions.ipynb (unless otherwise specified).

__all__ = ['GaussianMixtureDataGenerator', 'createMixture', 'pointsBetween', 'mycdf', 'clustersConflict',
           'jitterMixtures', 'getConflictingPairs', 'jitterComponents', 'generateComponents']

# Cell

from .randomParameters import NormalMixPNParameters2 as NMixPar
def GaussianMixtureDataGenerator(dim, n_comps, aucpn_range,irreducibility_range,timeoutMins=1,nTimeouts=5):
    #setting the thrid entry of irr_vec to False enforces pairwise mutual irreducibility
    #setting the thrid entry of irr_vec to True enforces the strong irreducibility.
    #The second entry of irr_vec is the the posterior threshold for irreducibility.
    #The first argument is the proportion of points that should high enough posterior.
    #Using 0.01 and 0.9 is easier to satisfy then 0.05 and 0.95. You may play with this,
    # but note that the stronger irreducibility criteria, the more difficult it is to be satisfied
    # and you might end up in infinite loop since no parameters could be founs to satisfy bo the
    # itrreducibility and auc criteria.
    irr_vec = irreducibility_range + [False]#[0.01, 0.9, False]
    NMix = NMixPar(dim, n_comps,aucpn_range, irr_vec,timeoutMins=timeoutMins,nTimeouts=nTimeouts)
#     NMix.perturb2SatisfyMetrics()
#     NMix.updateDataGenerator()
    dg = NMix.dg
    return NMix, dg

# Cell
from .distributions import mixture

def createMixture(NMix,cluster_num):
    gamma = NMix.alpha * NMix.p_pos[cluster_num] + (1 - NMix.alpha) * NMix.p_neg[cluster_num]
    eta = NMix.alpha * NMix.p_pos[cluster_num] / gamma
    m = mixture((NMix.dg.dist_pos.comps[cluster_num],
                 NMix.dg.dist_neg.comps[cluster_num]),(eta,1-eta))
    return m

# Cell
def pointsBetween(NMix,i,j):
    mixI = createMixture(NMix,i)
    mI = np.dot(mixI.mixProp,[c.mean for c in mixI.comps])
    vec = NMix.vecBetweenPair(i,j)
    for scale in np.arange(0,1,.01):
        yield mI - vec * scale

# Cell
import numpy as np
def mycdf(mixture,x,n_samples=10000):
    mixtureMean = mixture.mean
    d = np.linalg.norm(mixtureMean - x)**2
    dists = np.linalg.norm(mixture.rvs(n_samples) - mixtureMean,axis=-1)**2
    return (dists <= d).sum() / n_samples

# Cell
from tqdm import tqdm

def clustersConflict(NMix,i,j,quiet=False):
    if not quiet:
        print(f"checking {i} - {j}")
    mixI = createMixture(NMix,i)
    mixJ = createMixture(NMix,j)
    for x in tqdm(pointsBetween(NMix,i,j)):
        if (1 - mycdf(mixI,x)) > .05 and (1-mycdf(mixJ,x)) > .05:
            if not quiet:
                print(f"..... {i} - {j} conflict")
            return True
    if not quiet:
        print(f".... no conflict")
    return False

# Cell
from tqdm import tqdm,trange
from sklearn.metrics import roc_auc_score
from copy import deepcopy
from itertools import combinations
import scipy.stats as ss

def jitterMixtures(NMix,i,j,factor=5):
    t0 = np.random.uniform(-factor,factor,size=NMix.dg.components_pos[i].mean.shape)
    t1 = np.random.uniform(-factor,factor,size=NMix.dg.components_pos[j].mean.shape)
    NMix.dg.components_pos[i].mean += t0
    NMix.dg.components_neg[i].mean += t0
    NMix.dg.components_pos[j].mean -= t1
    NMix.dg.components_neg[j].mean -= t1
    return NMix

def getConflictingPairs(NMix):
    return [(i,j) for i,j in combinations(np.arange(NMix.nComps),2) if clustersConflict(NMix,i,j,quiet=True)]

def jitterComponents(NMix):
    print("getting conflicting pairs")
    pairs = getConflictingPairs(NMix)
    print("conflicting pairs")
    print(pairs)
    while len(pairs):
        print(pairs)
        for i,j in pairs:
            while clustersConflict(NMix,i,j):
                NMix = jitterMixtures(NMix,i,j)
        pairs = getConflictingPairs(NMix)
        print('conflicting pairs')
        print(pairs)
    return NMix

def generateComponents(n_clusters,dim,aucRange,irreducibility_range=[.01,1],timeoutMins=1,nTimeouts=5):
    print("making dg")
    NMix,dg = GaussianMixtureDataGenerator(dim,n_clusters,aucRange,irreducibility_range,timeoutMins=timeoutMins,nTimeouts=nTimeouts)
    print("done making dg")
    print("jittering comps")
    NMix = jitterComponents(NMix)
    print("done jittering comps")
    return NMix